package main

import (
	"bufio"
	"flag"
	"fmt"
	"os"
	"os/exec"
	"strings"
	"time"
)

const usage = `go-version - Generate and manage version files

Usage:
  go-version <command> [options]

Commands:
  file        Generate a .version file from git or manual input
  ldflags     Generate go build command with -ldflags for version injection
  show        Show version information from git

Run 'go-version <command> -h' for more information on a command.
`

const fileUsage = `Generate a .version file

Usage:
  go-version file [options]

Options:
  -o, -output     Output file path (default: .version)
  -v, -version    Version string (default: from git describe)
  -t, -timestamp  Build timestamp (default: current time)

Examples:
  go-version file                    # Generate from git
  go-version file -o build/.version  # Custom output path
  go-version file -v 1.2.3           # Manual version
`

const showUsage = `Show version information from git

Usage:
  go-version show
`

const ldflagsUsage = `Generate -ldflags value for version injection

Usage:
  go-version ldflags [options]

Options:
  -p, -package    Package path (default: auto-detected from go.mod)
  -v, -version    Version string (default: from git describe)
  -shell          Output shell command with $() substitutions (default)
  -static         Output static values instead of shell substitutions

Examples:
  go build -ldflags="$(go-version ldflags)"        # Use in build command
  go build -ldflags="$(go-version ldflags -static)" # Static values for CI
  go-version ldflags -p myapp/internal/version     # Custom package path
`

func main() {
	if len(os.Args) < 2 {
		fmt.Print(usage)
		os.Exit(0)
	}

	switch os.Args[1] {
	case "file":
		cmdFile(os.Args[2:])
	case "ldflags":
		cmdLdflags(os.Args[2:])
	case "show":
		cmdShow(os.Args[2:])
	case "-h", "--help", "help":
		fmt.Print(usage)
	default:
		fmt.Fprintf(os.Stderr, "Unknown command: %s\n\n", os.Args[1])
		fmt.Print(usage)
		os.Exit(1)
	}
}

func cmdFile(args []string) {
	fs := flag.NewFlagSet("file", flag.ExitOnError)
	fs.Usage = func() { fmt.Print(fileUsage) }

	var output, version, timestamp string
	fs.StringVar(&output, "o", ".version", "Output file path")
	fs.StringVar(&output, "output", ".version", "Output file path")
	fs.StringVar(&version, "v", "", "Version string")
	fs.StringVar(&version, "version", "", "Version string")
	fs.StringVar(&timestamp, "t", "", "Build timestamp")
	fs.StringVar(&timestamp, "timestamp", "", "Build timestamp")

	fs.Parse(args)

	// Gather git info
	commit := gitCommand("rev-parse", "HEAD")
	branch := gitCommand("rev-parse", "--abbrev-ref", "HEAD")
	repo := gitCommand("remote", "get-url", "origin")

	// Use git describe for version if not provided
	if version == "" {
		version = gitCommand("describe", "--tags", "--always")
	}

	// Use current time if timestamp not provided
	if timestamp == "" {
		timestamp = time.Now().UTC().Format(time.UnixDate)
	}

	// Build file content
	var sb strings.Builder
	sb.WriteString("# Generated by go-version\n")
	if version != "" {
		sb.WriteString(fmt.Sprintf("VERSION=%s\n", version))
	}
	if commit != "" {
		sb.WriteString(fmt.Sprintf("GIT_COMMIT=%s\n", commit))
	}
	if branch != "" {
		sb.WriteString(fmt.Sprintf("GIT_BRANCH=%s\n", branch))
	}
	if repo != "" {
		sb.WriteString(fmt.Sprintf("GIT_REPO=%s\n", repo))
	}
	sb.WriteString(fmt.Sprintf("BUILD_TIMESTAMP=%s\n", timestamp))

	// Write to file
	if err := os.WriteFile(output, []byte(sb.String()), 0644); err != nil {
		fmt.Fprintf(os.Stderr, "Error writing file: %v\n", err)
		os.Exit(1)
	}

	fmt.Printf("Generated %s\n", output)
}

func cmdShow(args []string) {
	fs := flag.NewFlagSet("show", flag.ExitOnError)
	fs.Usage = func() { fmt.Print(showUsage) }
	fs.Parse(args)

	commit := gitCommand("rev-parse", "HEAD")
	branch := gitCommand("rev-parse", "--abbrev-ref", "HEAD")
	repo := gitCommand("remote", "get-url", "origin")
	version := gitCommand("describe", "--tags", "--always")

	fmt.Printf("Version:  %s\n", valueOrNA(version))
	fmt.Printf("Commit:   %s\n", valueOrNA(commit))
	fmt.Printf("Branch:   %s\n", valueOrNA(branch))
	fmt.Printf("Repo:     %s\n", valueOrNA(repo))
}

func gitCommand(args ...string) string {
	cmd := exec.Command("git", args...)
	out, err := cmd.Output()
	if err != nil {
		return ""
	}
	return strings.TrimSpace(string(out))
}

func valueOrNA(s string) string {
	if s == "" {
		return "N/A"
	}
	return s
}

// getModulePath reads the module path from go.mod in current directory
func getModulePath() string {
	file, err := os.Open("go.mod")
	if err != nil {
		return ""
	}
	defer file.Close()

	scanner := bufio.NewScanner(file)
	for scanner.Scan() {
		line := strings.TrimSpace(scanner.Text())
		if strings.HasPrefix(line, "module ") {
			return strings.TrimSpace(strings.TrimPrefix(line, "module"))
		}
	}
	return ""
}

func cmdLdflags(args []string) {
	fs := flag.NewFlagSet("ldflags", flag.ExitOnError)
	fs.Usage = func() { fmt.Print(ldflagsUsage) }

	var pkg, version string
	var static bool
	fs.StringVar(&pkg, "p", "", "Package path")
	fs.StringVar(&pkg, "package", "", "Package path")
	fs.StringVar(&version, "v", "", "Version string")
	fs.StringVar(&version, "version", "", "Version string")
	fs.BoolVar(&static, "static", false, "Output static values")

	fs.Parse(args)

	// Auto-detect package from go.mod if not specified
	if pkg == "" {
		pkg = getModulePath()
		if pkg == "" {
			fmt.Fprintln(os.Stderr, "Error: could not detect module path from go.mod")
			fmt.Fprintln(os.Stderr, "Use -p to specify package path manually")
			os.Exit(1)
		}
	}

	var flags []string

	if static {
		// Static values - resolve everything now
		commit := gitCommand("rev-parse", "HEAD")
		branch := gitCommand("rev-parse", "--abbrev-ref", "HEAD")
		repo := gitCommand("remote", "get-url", "origin")
		timestamp := time.Now().UTC().Format(time.UnixDate)

		if version == "" {
			version = gitCommand("describe", "--tags", "--always")
		}

		if version != "" {
			flags = append(flags, fmt.Sprintf("-X '%s.VersionInfo=%s'", pkg, version))
		}
		if commit != "" {
			flags = append(flags, fmt.Sprintf("-X '%s.GitCommit=%s'", pkg, commit))
		}
		if branch != "" {
			flags = append(flags, fmt.Sprintf("-X '%s.GitBranch=%s'", pkg, branch))
		}
		if repo != "" {
			flags = append(flags, fmt.Sprintf("-X '%s.GitRepo=%s'", pkg, repo))
		}
		flags = append(flags, fmt.Sprintf("-X '%s.BuildTimestamp=%s'", pkg, timestamp))
	} else {
		// Shell substitutions for use in scripts/Makefiles
		if version != "" {
			flags = append(flags, fmt.Sprintf("-X '%s.VersionInfo=%s'", pkg, version))
		} else {
			flags = append(flags, fmt.Sprintf("-X '%s.VersionInfo=$(git describe --tags --always)'", pkg))
		}
		flags = append(flags, fmt.Sprintf("-X '%s.GitCommit=$(git rev-parse HEAD)'", pkg))
		flags = append(flags, fmt.Sprintf("-X '%s.GitBranch=$(git rev-parse --abbrev-ref HEAD)'", pkg))
		flags = append(flags, fmt.Sprintf("-X '%s.GitRepo=$(git remote get-url origin)'", pkg))
		flags = append(flags, fmt.Sprintf("-X '%s.BuildTimestamp=$(date -u \"+%%a %%b %%d %%H:%%M:%%S %%Z %%Y\")'", pkg))
	}

	fmt.Println(strings.Join(flags, " "))
}
