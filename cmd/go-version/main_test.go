package main

import (
	"bytes"
	"fmt"
	"io"
	"os"
	"os/exec"
	"path/filepath"
	"strings"
	"testing"
	"time"
)

// captureStdout runs fn and returns whatever it wrote to os.Stdout.
func captureStdout(t *testing.T, fn func()) string {
	t.Helper()
	old := os.Stdout
	r, w, err := os.Pipe()
	if err != nil {
		t.Fatal(err)
	}
	os.Stdout = w

	fn()

	w.Close()
	os.Stdout = old

	var buf bytes.Buffer
	io.Copy(&buf, r)
	return buf.String()
}

// requireGit skips the test if we're not inside a git repo.
func requireGit(t *testing.T) {
	t.Helper()
	if err := exec.Command("git", "rev-parse", "--git-dir").Run(); err != nil {
		t.Skipf("skipping: not in a git repository (%v)", err)
	}
}

// --- valueOrNA tests ---

func TestValueOrNA(t *testing.T) {
	tests := []struct {
		input string
		want  string
	}{
		{"hello", "hello"},
		{"", "N/A"},
		{" ", " "},
	}
	for _, tt := range tests {
		got := valueOrNA(tt.input)
		if got != tt.want {
			t.Errorf("valueOrNA(%q) = %q, want %q", tt.input, got, tt.want)
		}
	}
}

// --- gitCommand tests ---

func TestGitCommand_RevParseGitDir(t *testing.T) {
	requireGit(t)

	out := gitCommand("rev-parse", "--git-dir")
	if out == "" {
		t.Error("expected non-empty output for git rev-parse --git-dir")
	}
}

func TestGitCommand_RevParseHEAD(t *testing.T) {
	requireGit(t)

	out := gitCommand("rev-parse", "HEAD")
	if len(out) < 7 {
		t.Errorf("expected commit hash, got %q", out)
	}
}

func TestGitCommand_InvalidCommand(t *testing.T) {
	out := gitCommand("not-a-real-command")
	if out != "" {
		t.Errorf("expected empty string for invalid command, got %q", out)
	}
}

func TestGitCommand_TrimOutput(t *testing.T) {
	requireGit(t)

	out := gitCommand("rev-parse", "--abbrev-ref", "HEAD")
	if out != strings.TrimSpace(out) {
		t.Errorf("output should be trimmed, got %q", out)
	}
}

// --- cmdShow tests ---

func TestCmdShow(t *testing.T) {
	requireGit(t)

	output := captureStdout(t, func() {
		cmdShow(nil)
	})

	for _, label := range []string{"Version:", "Commit:", "Branch:", "Repo:"} {
		if !strings.Contains(output, label) {
			t.Errorf("show output should contain %q, got:\n%s", label, output)
		}
	}
}

func TestCmdShow_HasValues(t *testing.T) {
	requireGit(t)

	output := captureStdout(t, func() {
		cmdShow(nil)
	})

	// In a git repo, commit should not be N/A
	lines := strings.Split(strings.TrimSpace(output), "\n")
	for _, line := range lines {
		if strings.HasPrefix(line, "Commit:") {
			value := strings.TrimSpace(strings.TrimPrefix(line, "Commit:"))
			if value == "N/A" {
				t.Error("Commit should not be N/A inside a git repo")
			}
		}
	}
}

// --- cmdFile tests ---

func TestCmdFile_DefaultOutput(t *testing.T) {
	requireGit(t)

	dir := t.TempDir()
	outFile := filepath.Join(dir, ".version")

	output := captureStdout(t, func() {
		cmdFile([]string{"-o", outFile})
	})

	if !strings.Contains(output, "Generated") {
		t.Errorf("expected 'Generated' message, got %q", output)
	}

	data, err := os.ReadFile(outFile)
	if err != nil {
		t.Fatalf("failed to read output file: %v", err)
	}

	content := string(data)
	if !strings.Contains(content, "# Generated by go-version") {
		t.Error("file should contain header comment")
	}
	if !strings.Contains(content, "BUILD_TIMESTAMP=") {
		t.Error("file should contain BUILD_TIMESTAMP")
	}
	if !strings.Contains(content, "GIT_COMMIT=") {
		t.Error("file should contain GIT_COMMIT")
	}
}

func TestCmdFile_ManualVersion(t *testing.T) {
	requireGit(t)

	dir := t.TempDir()
	outFile := filepath.Join(dir, ".version")

	captureStdout(t, func() {
		cmdFile([]string{"-o", outFile, "-v", "1.2.3"})
	})

	data, err := os.ReadFile(outFile)
	if err != nil {
		t.Fatalf("failed to read output file: %v", err)
	}

	if !strings.Contains(string(data), "VERSION=1.2.3") {
		t.Errorf("file should contain VERSION=1.2.3, got:\n%s", data)
	}
}

func TestCmdFile_ManualTimestamp(t *testing.T) {
	requireGit(t)

	dir := t.TempDir()
	outFile := filepath.Join(dir, ".version")
	ts := "Mon Jan  2 15:04:05 UTC 2006"

	captureStdout(t, func() {
		cmdFile([]string{"-o", outFile, "-t", ts})
	})

	data, err := os.ReadFile(outFile)
	if err != nil {
		t.Fatalf("failed to read output file: %v", err)
	}

	if !strings.Contains(string(data), fmt.Sprintf("BUILD_TIMESTAMP=%s", ts)) {
		t.Errorf("file should contain the manual timestamp, got:\n%s", data)
	}
}

func TestCmdFile_AutoTimestamp(t *testing.T) {
	requireGit(t)

	dir := t.TempDir()
	outFile := filepath.Join(dir, ".version")
	before := time.Now().UTC()

	captureStdout(t, func() {
		cmdFile([]string{"-o", outFile})
	})

	data, err := os.ReadFile(outFile)
	if err != nil {
		t.Fatal(err)
	}

	// Extract the timestamp line
	for _, line := range strings.Split(string(data), "\n") {
		if strings.HasPrefix(line, "BUILD_TIMESTAMP=") {
			tsStr := strings.TrimPrefix(line, "BUILD_TIMESTAMP=")
			ts, err := time.Parse(time.UnixDate, tsStr)
			if err != nil {
				t.Fatalf("failed to parse auto timestamp %q: %v", tsStr, err)
			}
			if ts.Before(before.Add(-time.Second)) {
				t.Errorf("auto timestamp %v is before test start %v", ts, before)
			}
		}
	}
}

func TestCmdFile_LongFlagNames(t *testing.T) {
	requireGit(t)

	dir := t.TempDir()
	outFile := filepath.Join(dir, ".version")

	captureStdout(t, func() {
		cmdFile([]string{"-output", outFile, "-version", "4.5.6", "-timestamp", "Mon Jan  2 15:04:05 UTC 2006"})
	})

	data, err := os.ReadFile(outFile)
	if err != nil {
		t.Fatal(err)
	}

	content := string(data)
	if !strings.Contains(content, "VERSION=4.5.6") {
		t.Errorf("long flag -version should work, got:\n%s", content)
	}
}

// --- cmdVersion tests ---

func TestCmdVersion(t *testing.T) {
	output := captureStdout(t, func() {
		cmdVersion()
	})

	if !strings.HasPrefix(output, "go-version") {
		t.Errorf("version output should start with 'go-version', got:\n%s", output)
	}
}

// --- cmdLdflags tests ---

func TestCmdLdflags_ShellMode(t *testing.T) {
	requireGit(t)

	output := captureStdout(t, func() {
		cmdLdflags(nil)
	})

	pkg := "github.com/rbaliyan/go-version"
	// Shell mode should contain $() substitutions
	if !strings.Contains(output, "$(git") {
		t.Errorf("shell mode should contain $(git substitutions, got:\n%s", output)
	}
	if !strings.Contains(output, fmt.Sprintf("-X '%s.VersionInfo=", pkg)) {
		t.Errorf("should contain VersionInfo flag, got:\n%s", output)
	}
	if !strings.Contains(output, fmt.Sprintf("-X '%s.GitCommit=", pkg)) {
		t.Errorf("should contain GitCommit flag, got:\n%s", output)
	}
	if !strings.Contains(output, fmt.Sprintf("-X '%s.GitBranch=", pkg)) {
		t.Errorf("should contain GitBranch flag, got:\n%s", output)
	}
	if !strings.Contains(output, fmt.Sprintf("-X '%s.GitRepo=", pkg)) {
		t.Errorf("should contain GitRepo flag, got:\n%s", output)
	}
	if !strings.Contains(output, fmt.Sprintf("-X '%s.BuildTimestamp=", pkg)) {
		t.Errorf("should contain BuildTimestamp flag, got:\n%s", output)
	}
}

func TestCmdLdflags_ShellModeWithVersion(t *testing.T) {
	requireGit(t)

	output := captureStdout(t, func() {
		cmdLdflags([]string{"-v", "1.2.3"})
	})

	// When version is provided, it should appear literally (not as shell substitution)
	if !strings.Contains(output, "VersionInfo=1.2.3'") {
		t.Errorf("should contain literal version, got:\n%s", output)
	}
	// Other flags should still use shell substitutions
	if !strings.Contains(output, "$(git rev-parse HEAD)") {
		t.Errorf("GitCommit should use shell substitution, got:\n%s", output)
	}
}

func TestCmdLdflags_StaticMode(t *testing.T) {
	requireGit(t)

	output := captureStdout(t, func() {
		cmdLdflags([]string{"-static"})
	})

	// Static mode should NOT contain $() substitutions
	if strings.Contains(output, "$(git") {
		t.Errorf("static mode should not contain shell substitutions, got:\n%s", output)
	}
	// Should contain actual resolved values
	if !strings.Contains(output, "GitCommit=") {
		t.Errorf("should contain GitCommit, got:\n%s", output)
	}
}

func TestCmdLdflags_StaticModeWithVersion(t *testing.T) {
	requireGit(t)

	output := captureStdout(t, func() {
		cmdLdflags([]string{"-static", "-v", "9.8.7"})
	})

	if !strings.Contains(output, "VersionInfo=9.8.7'") {
		t.Errorf("should contain provided version, got:\n%s", output)
	}
}

func TestCmdLdflags_CustomPackage(t *testing.T) {
	requireGit(t)

	output := captureStdout(t, func() {
		cmdLdflags([]string{"-p", "github.com/custom/pkg"})
	})

	if !strings.Contains(output, "github.com/custom/pkg.VersionInfo=") {
		t.Errorf("should use custom package path, got:\n%s", output)
	}
}

func TestCmdLdflags_LongFlagNames(t *testing.T) {
	requireGit(t)

	output := captureStdout(t, func() {
		cmdLdflags([]string{"-package", "github.com/org/app", "-version", "5.0.0", "-static"})
	})

	if !strings.Contains(output, "github.com/org/app.VersionInfo=5.0.0'") {
		t.Errorf("long flags should work, got:\n%s", output)
	}
}

// --- main() integration tests via subprocess ---

func TestMain_Help(t *testing.T) {
	binary := buildTestBinary(t)

	out, err := exec.Command(binary, "help").CombinedOutput()
	if err != nil {
		t.Fatalf("help command failed: %v\n%s", err, out)
	}
	if !strings.Contains(string(out), "go-version") {
		t.Errorf("help output should contain 'go-version', got:\n%s", out)
	}
	if !strings.Contains(string(out), "Commands:") {
		t.Errorf("help output should list commands, got:\n%s", out)
	}
}

func TestMain_HelpFlag(t *testing.T) {
	binary := buildTestBinary(t)

	out, err := exec.Command(binary, "--help").CombinedOutput()
	if err != nil {
		t.Fatalf("--help flag failed: %v\n%s", err, out)
	}
	if !strings.Contains(string(out), "Commands:") {
		t.Errorf("--help should show usage, got:\n%s", out)
	}
}

func TestMain_NoArgs(t *testing.T) {
	binary := buildTestBinary(t)

	out, err := exec.Command(binary).CombinedOutput()
	if err != nil {
		t.Fatalf("no-args invocation failed: %v\n%s", err, out)
	}
	if !strings.Contains(string(out), "Usage:") {
		t.Errorf("no-args should show usage, got:\n%s", out)
	}
}

func TestMain_UnknownCommand(t *testing.T) {
	binary := buildTestBinary(t)

	out, err := exec.Command(binary, "bogus").CombinedOutput()
	if err == nil {
		t.Error("expected non-zero exit for unknown command")
	}
	if !strings.Contains(string(out), "Unknown command: bogus") {
		t.Errorf("should report unknown command, got:\n%s", out)
	}
}

func TestMain_VersionFlag(t *testing.T) {
	binary := buildTestBinary(t)

	out, err := exec.Command(binary, "-v").CombinedOutput()
	if err != nil {
		t.Fatalf("-v flag failed: %v\n%s", err, out)
	}
	if !strings.HasPrefix(string(out), "go-version") {
		t.Errorf("-v should show version, got:\n%s", out)
	}
}

func TestMain_ShowCommand(t *testing.T) {
	requireGit(t)
	binary := buildTestBinary(t)

	out, err := exec.Command(binary, "show").CombinedOutput()
	if err != nil {
		t.Fatalf("show command failed: %v\n%s", err, out)
	}
	if !strings.Contains(string(out), "Version:") {
		t.Errorf("show should display version info, got:\n%s", out)
	}
}

func TestMain_FileCommand(t *testing.T) {
	requireGit(t)
	binary := buildTestBinary(t)

	dir := t.TempDir()
	outFile := filepath.Join(dir, ".version")

	out, err := exec.Command(binary, "file", "-o", outFile, "-v", "1.0.0").CombinedOutput()
	if err != nil {
		t.Fatalf("file command failed: %v\n%s", err, out)
	}

	data, err := os.ReadFile(outFile)
	if err != nil {
		t.Fatal(err)
	}
	if !strings.Contains(string(data), "VERSION=1.0.0") {
		t.Errorf("generated file should contain version, got:\n%s", data)
	}
}

func TestMain_LdflagsCommand(t *testing.T) {
	requireGit(t)
	binary := buildTestBinary(t)

	out, err := exec.Command(binary, "ldflags", "-static", "-v", "2.0.0").CombinedOutput()
	if err != nil {
		t.Fatalf("ldflags command failed: %v\n%s", err, out)
	}
	if !strings.Contains(string(out), "VersionInfo=2.0.0") {
		t.Errorf("ldflags should contain version, got:\n%s", out)
	}
}

// testBinaryDir holds the temporary directory for the compiled test binary.
// It is created once in TestMain and cleaned up after all tests run.
var (
	testBinaryPath string
	testBinaryDir  string
)

func TestMain(m *testing.M) {
	// Build the binary once before all tests.
	dir, err := os.MkdirTemp("", "go-version-test-*")
	if err != nil {
		fmt.Fprintf(os.Stderr, "failed to create temp dir: %v\n", err)
		os.Exit(1)
	}
	testBinaryDir = dir

	binary := filepath.Join(dir, "go-version-test")
	modRoot, err := getModuleRoot()
	if err != nil {
		fmt.Fprintf(os.Stderr, "failed to find module root: %v\n", err)
		os.RemoveAll(dir)
		os.Exit(1)
	}

	cmd := exec.Command("go", "build", "-o", binary, ".")
	cmd.Dir = filepath.Join(modRoot, "cmd", "go-version")
	if out, err := cmd.CombinedOutput(); err != nil {
		fmt.Fprintf(os.Stderr, "failed to build test binary: %v\n%s\n", err, out)
		os.RemoveAll(dir)
		os.Exit(1)
	}
	testBinaryPath = binary

	code := m.Run()
	os.RemoveAll(dir)
	os.Exit(code)
}

func buildTestBinary(t *testing.T) string {
	t.Helper()
	if testBinaryPath == "" {
		t.Fatal("test binary not built; TestMain should have built it")
	}
	return testBinaryPath
}

func getModuleRoot() (string, error) {
	out, err := exec.Command("go", "env", "GOMOD").Output()
	if err != nil {
		return "", err
	}
	return filepath.Dir(strings.TrimSpace(string(out))), nil
}
